---
title: "R Notebook"
output: html_notebook
---

This notebook is for the exploration of sentencing information, and also serves as a place to test AW's `clean_periods` function.

```{r}
library(tidyverse)
```

This loads AW's functions into my namespace (and makes them available).

```{r}
source(file.path(rprojroot::find_root(rprojroot::is_rstudio_project),
                 "analyses", "team1", "exploration", "aw_functions.R"))
```

The sentencing information from dispositions is pretty messy. Let's take a look at the most common values. This is a large file but a modern computer should fit it into RAM without much trouble.

```{r}
dispositions <- read_csv(file.path(rprojroot::find_root(rprojroot::is_rstudio_project),
                                   "data", "offenses_dispositions.csv"),
                         col_types = cols(
  docket_id = col_double(),
  description = col_character(),
  statute_description = col_character(),
  sequence_number = col_double(),
  grade = col_character(),
  disposition = col_character(),
  disposing_authority__first_name = col_character(),
  disposing_authority__middle_name = col_character(),
  disposing_authority__last_name = col_character(),
  disposing_authority__title = col_character(),
  disposing_authority__document_name = col_character(),
  disposition_method = col_character(),
  min_period = col_character(),
  max_period = col_character(),
  period = col_character(),
  sentence_type = col_character()
))
```

How many unique `period` values?

```{r}
dispositions %>%
  summarize(across(c(min_period, max_period, period), n_distinct))
```

Wow, that's a lot of different ways to write things. Print the first 20 rows of the sentence `period`s to see what we're dealing with.

```{r}
dispositions %>%
  count(period) %>%
  arrange(desc(n)) %>%
  head(10)
```

AW's functions currently focus on `min_period` and `max_period`. Are these reliable?

```{r}
dispositions %>%
  select(ends_with("period"))
```

```{r}
dispositions %>%
 filter(!is.na(period),
        is.na(min_period),
        is.na(max_period)) %>%
  count(period) %>%
  arrange(desc(n)) %>%
  head(20)
```

No, unfortunately not — there are plenty of cases where both `min_period` and `max_period` are `NA`, but `period` contains valid data.

# Okay let's start dealing with periods

First let's make sure there aren't multiple kinds of hyphens.

```{r}
# en and em dash
str_subset(dispositions$period,
           "(–|—)")
```

This is gnarly and will get tucked into a function later.

```{r}
clean_periods <- dispositions$period %>%
  tolower() %>%
  str_replace_all("[[:blank:]]+", " ") %>%
  str_replace("^ ", "") %>%
  str_replace_all(" $", "")

# Deal with the many ways of writing ".5"
clean_periods <- clean_periods %>%
  str_replace_all("([[:digit:]]+) - 1/2", "\\1.5") %>%
  str_replace_all("([[:digit:]]+) 1/2", "\\1.5") %>%
  str_replace_all("([[:digit:]]+) and a half", "\\1.5") 

# Tokenize "time in"/"time-in", "time served" and some typos
clean_periods <- clean_periods %>%
  str_replace("tiime", "time") %>%
  str_replace("tim ", "time") %>%
  str_replace("time[ -]?(served|in)", "time_served")

# Standardize units
clean_periods <- clean_periods %>%
  str_replace_all("hrs", "hours") %>%
  str_replace_all("hour(?!s)",  "hours") %>%
  str_replace_all("day(?!s)",   "days") %>%
  str_replace_all("month(?!s)", "months") %>%
  str_replace_all("year(?!s)",  "years")

# Standardize the "time arithmetic"
clean_periods <- clean_periods %>%
  str_replace_all(" and ", " plus ") %>%
  str_replace_all(" less ", " minus ")
# This one's tricky, in part because str_replace_all is greedier than it should be
operator_insertion_regexp <- "^([[:digit:]]+) ([[:alpha:]]+) ([[:digit:]]+) ([[:alpha:]]+)$"
needs_operator_inserted <- !is.na(clean_periods) &
  str_detect(clean_periods, operator_insertion_regexp) & 
  (str_replace(clean_periods, operator_insertion_regexp, "\\2") != "to")
clean_periods[needs_operator_inserted] <- str_replace_all(clean_periods[needs_operator_inserted],
                                                           operator_insertion_regexp,
                                                           "\\1 \\2 plus \\3 \\4")

# Split the periods using "-" or "to"
clean_periods_split <- clean_periods %>%
  str_split_fixed("\\s?((\\bto\\b)|-)\\s?", 2)
  #str_split_fixed("\\s?((\\bto\\b)|(-(?!.*\\bto\\b)))\\s?", 2)

# If the beginning period is missing a time unit (days, months, years), grab it from the end period
is_missing_units <- str_detect(clean_periods_split[, 1], "^[[:digit:]]+(\\.5)?$")
# Pulling out the first units word is a bit tricky
missing_units <- clean_periods_split[is_missing_units, 2] %>%
  str_extract("^[[:digit:]]+(\\.5)? [[:alpha:]]+") %>%
  str_extract("[[:alpha:]]+$")
clean_periods_split[is_missing_units, 1] <- paste(clean_periods_split[is_missing_units, 1],
                                                   missing_units, sep = " ")

clean_periods_split %>%
  as.data.frame() %>%
  distinct() %>%
  arrange(desc(V1)) %>%
  print.AsIs()
```

At this point I'd like to have a way of dealing with `time_served`, or know that there is no good way to deal with it, before proceding. 
